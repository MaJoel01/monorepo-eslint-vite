# Lix Deterministic Mode

Deterministic mode enables reproducible behavior in Lix by controlling all sources of non-determinism (timestamps, IDs, and randomness). This is essential for:

- **Deterministic Simulation Testing (DST)** - Run the same test across multiple simulated environments to verify robustness
- **Debugging distributed systems** - Reproduce exact sequences of events across multiple Lix instances
- **Time-travel debugging** - Replay application state with identical IDs and timestamps
- **Testing conflict resolution** - Simulate concurrent modifications with predictable IDs
- **Regression testing** - Ensure tests produce identical results across runs

## Getting Started

To enable deterministic mode, set the `lix_deterministic_mode` key when opening a Lix file:

```ts
import { openLix } from "@lix-js/sdk";

const lix = await openLix({
  blob: await yourBlob,
  keyValues: [
    { key: "lix_deterministic_mode", value: true, lixcol_version_id: "global" }
  ]
});
```

Once enabled, all IDs, timestamps, and random values become deterministic and reproducible.

## Overview

These _functional_ helpers expose the three independent entropy sources used in deterministic‑simulation tests:

| Helper                        | Kind of entropy       | Typical use‑cases                                   |
| ----------------------------- | --------------------- | --------------------------------------------------- |
| `timestamp({ lix })`          | Logical clock         | `createdAt`, TTL, “time‑ordered” queries            |
| `nextSequenceNumber({ lix })` | Monotone counter      | Collision‑free IDs (`ENTITY_7`), pagination cursors |
| `random({ lix })`             | Replayable randomness | Sampling, shuffle, deterministic jitter             |


## Key properties

- **Deterministic** – identical blobs + seeds ⇒ identical sequences across runs/platforms.
- **State‑persisted** – every successful mutating transaction and every `lix.toBlob()`/`lix.close()` flushes updated state to `internal_state_all_untracked`.
- **Pure call‑site API** – no globals; each helper requires `{ lix }`.


## API reference

### `timestamp({ lix }): string`

Returns the current **logical timestamp** as an ISO 8601 string.
Clock advances according to implementation (e.g. +1 ms per write).

```ts
const t = timestamp({ lix }); // "1970-01-01T00:00:00.000Z", "1970-01-01T00:00:00.001Z", …
```

**Guarantees**

- Monotone, never decreases.
- Persisted and resumed on re‑open / clone.


### `nextSequenceNumber({ lix }): number`

Returns the next **monotone sequence number**, starting at 0.

```ts
const n = nextSequenceNumber({ lix }); // 0, 1, 2, …
```

**Guarantees**

- Strictly +1 each call, no gaps or duplicates.
- Persisted via `lix_deterministic_counter` record.


### `random({ lix }): number`

Returns a deterministic pseudo‑random float `r` where `0 ≤ r < 1`, generated by a seed‑initialised xoshiro128\*\* PRNG.

```ts
const r = random({ lix }); // 0.318…, 0.937…, …
```

**Seeding rules**

- First run → seed defaults to the Lix UUID.
- Override by inserting `lix_deterministic_rng_seed` **before** first `random()` call.
- PRNG state persisted on each call.


## Flush protocol

| Event                          | Counter/RNG/Clock state flushed? |
| ------------------------------ | -------------------------------- |
| Successful mutating Tx         | ✅                               |
| `lix.toBlob()` / `lix.close()` | ✅                               |
| Read‑only Tx (`SELECT`)        | ❌                               |
| Tx rollback / error            | ❌ (state rolled back)           |

All state is stored in `internal_state_all_untracked` (`version_id = "global"`).


## Edge‑cases

| Scenario                                        | Behaviour                                                                   |
| ----------------------------------------------- | --------------------------------------------------------------------------- |
| Clone blob, change only `lix_deterministic_rng_seed` | `random()` diverges, `timestamp()` & `nextSequenceNumber()` remain aligned. |
| Sequence overflow (`> Number.MAX_SAFE_INTEGER`) | Helpers throw; requires schema migration.                                   |
| Parallel Lix objects in same process            | Independent state; helpers require explicit `{ lix }` arg.                  |


## Extensibility (non‑breaking)

- `timestampMode` key to configure tick policy (`"write"`, `"step"`, `"manual"`).
- `randomAlgorithm` key to choose alternate PRNG (`"xoshiro"`, `"counter‑hash"`).
- Namespaced counters via future `nextSequenceNumber({ lix, namespace })`.


## Example

```ts
import { timestamp, random, nextSequenceNumber } from "@lix-js/sdk";

const t1 = timestamp({ lix }); // "1970-01-01T00:00:00.000Z"
const n1 = nextSequenceNumber({ lix }); // 0
const r1 = random({ lix }); // 0.318…

await lix.db.insertInto("kv").values({ key: "foo", value: "bar" }).execute();

const t2 = timestamp({ lix }); // "1970-01-01T00:00:00.001Z"
const n2 = nextSequenceNumber({ lix }); // 1
const r2 = random({ lix }); // 0.937…
```

## FAQ

### When should I use deterministic mode?

Use deterministic mode for:
- Unit and integration tests
- Debugging distributed systems
- Reproducing bug reports
- Deterministic simulation testing

Avoid it in production unless you specifically need reproducible IDs/timestamps.

### Is there a performance cost?

Minimal. The deterministic functions have similar performance to their non-deterministic counterparts.

### Can I use deterministic mode with existing Lix files?

Yes, but only new operations will be deterministic. Existing IDs and timestamps remain unchanged.

### How do I make multiple Lix instances behave differently?

Change the RNG seed before calling `random()`:

```ts
// Instance 1
await lix1.db.insertInto("key_value")
  .values({ key: "lix_deterministic_rng_seed", value: "instance-1" })
  .execute();

// Instance 2  
await lix2.db.insertInto("key_value")
  .values({ key: "lix_deterministic_rng_seed", value: "instance-2" })
  .execute();

// Now random() will produce different sequences
const r1 = random({ lix: lix1 }); // Different values
const r2 = random({ lix: lix2 }); // for each instance
```

