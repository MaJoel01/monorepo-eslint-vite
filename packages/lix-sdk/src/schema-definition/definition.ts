import type { FromSchema, JSONSchema } from "json-schema-to-ts";

export const LixSchemaDefinition = {
	$schema: "http://json-schema.org/draft-07/schema#",
	title: "Lix Change Schema",
	description:
		"A JSON schema document that also includes custom x-key and x-version properties for identification and versioning.",
	allOf: [
		{
			$ref: "http://json-schema.org/draft-07/schema#",
		},
		{
			type: "object",
			properties: {
				"x-lix-unique": {
					type: "array",
					items: {
						type: "array",
						items: {
							type: "string",
						},
					},
				},
				"x-primary-key": {
					type: "array",
					items: {
						type: "string",
					},
				},
				"x-lix-foreign-keys": {
					type: "object",
					additionalProperties: {
						type: "object",
						properties: {
							schemaKey: {
								type: "string",
								description: "The x-lix-key of the referenced schema",
							},
							property: {
								type: "string",
								description: "The property name in the referenced schema",
							},
							schemaVersion: {
								type: "string",
								pattern: "^\\d+\\.\\d+$",
								description: "Optional version of the referenced schema",
							},
						},
						required: ["schemaKey", "property"],
					},
				},
				"x-lix-key": {
					type: "string",
					description:
						"The key of the schema. The key is used to identify the schema. You must use a unique key for each schema.",
					examples: ["csv_plugin_cell"],
				},
				"x-lix-version": {
					type: "string",
					description:
						"The version of the schema. Use the major version to signal breaking changes. Use the minor version to signal non-breaking changes.",
					pattern: "^\\d+\\.\\d+$",
					examples: ["1.0"],
				},
				"properties": {
					type: "object",
					additionalProperties: {
						allOf: [
							{ $ref: "http://json-schema.org/draft-07/schema#" },
							{
								type: "object",
								properties: {
									"x-lix-generated": {
										type: "boolean",
										description: "Whether this property is auto-generated by the database"
									}
								}
							}
						]
					}
				},
			},
			required: ["x-lix-key", "x-lix-version"],
		},
	],
} as const;

/**
 * Extended property schema that includes Lix-specific extensions
 */
type LixPropertySchema = JSONSchema & {
	"x-lix-generated"?: boolean;
};

/**
 * LixSchema
 *
 * A superset of JSON Schema (draft-07) that includes Lix-specific metadata
 * and supports custom extensions.
 *
 * Custom extensions may be added with any x-* prefix.
 */
export type LixSchemaDefinition = JSONSchema & {
	/**
	 * The key of the schema.
	 *
	 * The key is used to identify the schema. You must use a
	 * unique key for each schema.
	 *
	 * @example
	 *   "csv_plugin_cell"
	 */
	"x-lix-key": string;
	/**
	 * The version of the schema.
	 *
	 * Use the major version to signal breaking changes.
	 * Use the minor version to signal non-breaking changes.
	 *
	 * @example
	 *   "1.0"
	 */
	"x-lix-version": string;
	"x-lix-primary-key"?: string[] | readonly string[];
	/**
	 * Properties that must be unique per version.
	 *
	 * Not to be confused by `x-version` which is used for versioning the schema.
	 *
	 *
	 * @example
	 *   {
	 *     "x-lix-unique": [
	 *       // the id must be unique
	 *       ["id"],
	 *       // the name and age must be unique as well
	 *       ["name", "age"],
	 *     ],
	 *     properties: {
	 *       id: { type: "string" },
	 *       name: { type: "string" },
	 *       age: { type: "number" },
	 *     },
	 *   }
	 */
	"x-lix-unique"?: string[][] | readonly (readonly string[])[];
	/**
	 * Foreign key constraints referencing other schemas.
	 *
	 * @example
	 *   {
	 *     "x-lix-foreign-keys": {
	 *       "author_id": {
	 *         "schemaKey": "user_profile",
	 *         "property": "id"
	 *       },
	 *       "category_id": {
	 *         "schemaKey": "post_category",
	 *         "property": "id"
	 *       }
	 *     }
	 *   }
	 */
	"x-lix-foreign-keys"?: {
		[localProperty: string]: {
			schemaKey: string;
			property: string;
			schemaVersion?: string;
		};
	};
	type: "object";
	properties?: {
		[key: string]: LixPropertySchema;
	};
};

/**
 * Our own Generated marker type for database columns that are auto-generated.
 * This allows us to control type transformations independently of Kysely.
 * 
 * Note: For developer convenience, this accepts T values but preserves
 * the generated marker for type transformations.
 */
export type LixGenerated<T> = T & {
	readonly __lixGenerated?: true;
};

/**
 * Check if a type has the LixGenerated brand
 */
type IsLixGenerated<T> = T extends { readonly __lixGenerated?: true } ? true : false;

/**
 * Extract the base type from LixGenerated<T>
 * Since LixGenerated<T> = T & { brand }, we need to extract T
 */
type ExtractFromGenerated<T> = T extends LixGenerated<infer U> ? U : T;

/**
 * Extract the select type from LixGenerated or return the type as-is
 */
type SelectType<T> = ExtractFromGenerated<T>;

/**
 * Extract the insert type from LixGenerated or return the type as-is
 */
type InsertType<T> = IsLixGenerated<T> extends true ? ExtractFromGenerated<T> | undefined : T;

/**
 * Extract the update type from LixGenerated or return the type as-is
 */
type UpdateType<T> = ExtractFromGenerated<T>;

/**
 * Evaluates to K if T can be null or undefined
 */
type IfNullable<T, K> = undefined extends T ? K : null extends T ? K : never;

/**
 * Evaluates to K if T can't be null or undefined
 */
type IfNotNullable<T, K> = undefined extends T
	? never
	: null extends T
		? never
		: T extends never
			? never
			: K;

/**
 * Keys whose InsertType can be null or undefined (optional in inserts)
 */
type NullableInsertKeys<T> = {
	[K in keyof T]: IfNullable<InsertType<T[K]>, K>;
}[keyof T];

/**
 * Keys whose InsertType can't be null or undefined (required in inserts)
 */
type NonNullableInsertKeys<T> = {
	[K in keyof T]: IfNotNullable<InsertType<T[K]>, K>;
}[keyof T];

/**
 * Transform a type to make LixGenerated fields optional (for inserts).
 * Non-generated fields remain required.
 */
export type LixInsertable<T> = {
	[K in NonNullableInsertKeys<T>]: InsertType<T[K]>;
} & {
	[K in NullableInsertKeys<T>]?: InsertType<T[K]>;
};

/**
 * Transform a type to make all fields optional (for updates).
 * LixGenerated fields are unwrapped to their base type.
 */
export type LixUpdateable<T> = {
	[K in keyof T]?: UpdateType<T[K]>;
};

/**
 * Transform a type to unwrap LixGenerated fields (for selects).
 * This gives you the actual runtime types.
 */
export type LixSelectable<T> = {
	[K in keyof T]: SelectType<T[K]>;
};

/**
 * Internal type that applies LixGenerated markers to properties with x-lix-generated: true
 */
type ApplyLixGenerated<TSchema extends LixSchemaDefinition> = TSchema extends {
	properties: infer Props;
}
	? {
			[K in keyof FromSchema<TSchema>]: K extends keyof Props
				? Props[K] extends { "x-lix-generated": true }
					? LixGenerated<FromSchema<TSchema>[K]>
					: FromSchema<TSchema>[K]
				: FromSchema<TSchema>[K];
		}
	: never;

/**
 * Convert a LixSchemaDefinition to a TypeScript type.
 * Properties marked with x-lix-generated: true are wrapped in LixGenerated.
 * 
 * @example
 * ```typescript
 * const LogSchema = {
 *   properties: {
 *     id: { type: "string", "x-lix-generated": true },
 *     name: { type: "string" }
 *   }
 * } as const;
 * 
 * type Log = FromLixSchemaDefinition<typeof LogSchema>;
 * // Result: { id: LixGenerated<string>, name: string }
 * ```
 */
export type FromLixSchemaDefinition<T extends LixSchemaDefinition> =
	ApplyLixGenerated<T>;
